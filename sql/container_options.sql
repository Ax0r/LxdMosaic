CREATE TABLE `Container_Options` (
    `CO_ID` INT(11) NOT NULL AUTO_INCREMENT,
    `CO_Key` VARCHAR(255) NOT NULL,
    `CO_Type` VARCHAR(255) NOT NULL,
    `CO_Default` VARCHAR(255) NOT NULL,
    `CO_Live_Update` VARCHAR(255) NOT NULL,
    `CO_Api_Extension` VARCHAR(255) NOT NULL,
    `CO_Description` TEXT NOT NULL,
    `CO_Enabled` BOOLEAN NOT NULL,
    PRIMARY KEY(`CO_ID`)
);


INSERT INTO `Container_Options` (
    `CO_Key`,
    `CO_Type`,
    `CO_Default`,
    `CO_Live_Update`,
    `CO_Api_Extension`,
    `CO_Description`,
    `CO_Enabled`
) VALUES
("boot.autostart","boolean", "-", "n/a", "-", "Always start the container when LXD starts (if not set, restore last state)", "1"),
("boot.autostart.delay","integer","0","n/a","-","Number of seconds to wait after the container started before starting the next one","1"),
("boot.autostart.priority","integer","0","n/a","-","What order to start the containers in (starting with highest)","1"),
("boot.host_shutdown_timeout","integer","30","yes","container_host_shutdown_timeout","Seconds to wait for container to shutdown before it is force stopped","0"),
("boot.stop.priority","integer","0","n/a","container_stop_priority","What order to shutdown the containers (starting with highest)","0"),
("environment.*","string","-","yes (exec)","-","key/value environment variables to export to the container and set on exec","0"),
("limits.cpu","string","- ","yes","-","Number or range of CPUs to expose to the container","1"),
("limits.cpu.allowance","string","100%","yes","-","How much of the CPU can be used. Can be a percentage (e.g. 50%) for a soft limit or hard a chunk of time (25ms/100ms)","1"),
("limits.cpu.priority","integer","10","yes","-","CPU scheduling priority compared to other containers sharing the same CPUs (overcommit) (integer between 0 and 10)","1"),
("limits.disk.priority","integer","5","yes","-","When under load, how much priority to give to the container's I/O requests (integer between 0 and 10)","1"),
("limits.kernel.*","string","-","no","kernel_limits","This limits kernel resources per container (e.g. number of open files)","0"),
("limits.memory","string","-","yes","-","Percentage of the host's memory or fixed value in bytes (various suffixes supported, see below)","1"),
("limits.memory.enforce","string","hard","yes","-","If hard, container can't exceed its memory limit. If soft, the container can exceed its memory limit when extra host memory is available.","1"),
("limits.memory.swap","boolean","true","yes","-","Whether to allow some of the container's memory to be swapped out to disk","1"),
("limits.memory.swap.priority","integer","10","yes","-","The higher this is set, the least likely the container is to be swapped to disk (integer between 0 and 10)","1"),
("limits.network.priority","integer","0","yes","-","When under load, how much priority to give to the container's network requests (integer between 0 and 10)","1"),
("limits.processes","integer","-","yes","-","Maximum number of processes that can run in the container","1"),
("linux.kernel_modules","string","-","yes","-","Comma separated list of kernel modules to load before starting the container","1"),
("migration.incremental.memory","boolean","false","yes","migration_pre_copy","Incremental memory transfer of the container's memory to reduce downtime.","0"),
("migration.incremental.memory.goal","integer","70","yes","migration_pre_copy","Percentage of memory to have in sync before stopping the container.","0"),
("migration.incremental.memory.iterations","integer","10","yes","migration_pre_copy","Maximum number of transfer operations to go through before stopping the container.","0"),
("nvidia.driver.capabilities","string","compute,utility","no","nvidia_runtime_config","What driver capabilities the container needs (sets libnvidia-container NVIDIA_DRIVER_CAPABILITIES)","0"),
("nvidia.runtime","boolean","false","no","nvidia_runtime","Pass the host NVIDIA and CUDA runtime libraries into the container","0"),
("nvidia.require.cuda","string","-","no","nvidia_runtime_config","Version expression for the required CUDA version (sets libnvidia-container NVIDIA_REQUIRE_CUDA)","0"),
("nvidia.require.driver","string","-","no","nvidia_runtime_config","Version expression for the required driver version (sets libnvidia-container NVIDIA_REQUIRE_DRIVER)","0"),
("raw.apparmor","blob","-","yes","-","Apparmor profile entries to be appended to the generated profile","1"),
("raw.idmap","blob","-","no","id_map","Raw idmap configuration (e.g. 'both 1000 1000')","0"),
("raw.lxc","blob","-","no","-","Raw LXC configuration to be appended to the generated one","1"),
("raw.seccomp","blob","-","no","container_syscall_filtering","Raw Seccomp configuration","0"),
("security.devlxd","boolean","true","no","restrict_devlxd","Controls the presence of /dev/lxd in the container","0"),
("security.devlxd.images","boolean","false","no","devlxd_images","Controls the availability of the /1.0/images API over devlxd","0"),
("security.idmap.base","integer","-","no","id_map_base","The base host ID to use for the allocation (overrides auto-detection)","0"),
("security.idmap.isolated","boolean","false","no","id_map","Use an idmap for this container that is unique among containers with isolated set.","0"),
("security.idmap.size","integer","-","no","id_map","The size of the idmap to use","0"),
("security.nesting","boolean","false","yes","-","Support running lxd (nested) inside the container","1"),
("security.privileged","boolean","false","no","-","Runs the container in privileged mode","1"),
("security.protection.delete","boolean","false","yes","container_protection_delete","Prevents the container from being deleted","0"),
("security.protection.shift","boolean","false","yes","container_protection_shift","Prevents the container's filesystem from being uid/gid shifted on startup","0"),
("security.syscalls.blacklist","string","-","no","container_syscall_filtering","A '\n' separated list of syscalls to blacklist","0"),
("security.syscalls.blacklist_compat","boolean","false","no","container_syscall_filtering","On x86_64 this enables blocking of compat_* syscalls, it is a no-op on other arches","0"),
("security.syscalls.blacklist_default","boolean","true","no","container_syscall_filtering","Enables the default syscall blacklist","0"),
("security.syscalls.whitelist","string","-","no","container_syscall_filtering","A '\n' separated list of syscalls to whitelist (mutually exclusive with security.syscalls.blacklist*)","0"),
("snapshots.schedule","string","-","no","snapshot_scheduling","Cron expression (<minute> <hour> <dom> <month> <dow>)","0"),
("snapshots.schedule.stopped","bool","false","no","snapshot_scheduling","Controls whether or not stopped containers are to be snapshoted automatically","0"),
("snapshots.pattern","string","snap%d","no","snapshot_scheduling","Pongo2 template string which represents the snapshot name (used for scheduled snapshots and unnamed snapshots)","0"),
("user.*","string","-","n/a","-","","0");
